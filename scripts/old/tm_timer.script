--[[Таймеры.]]
local active_timers = {}
--[[
инициализирует таймер реального времени
time_ms - время в миллисекундах, через сколько вызвать функцию
action - имя функции вида name_module.name_function
tbl_arg - таблица аргументов
step - для циклов, шаг в миллисекундах,
при этом можно задать другое time_ms (первый страт) и тамер будет сохранятся в пакет или
true если сохранять этот таймер или false если не сохранять таймер
при булевом значении step шаг цикла берется за time_ms
сохранаемый таймер использовать для выброса, для какихто быстрых апдейтов юзать false
start_timer(10000,"mod.func"[,{...}]) --сохранится, вызов 1 раз
start_timer(10000,"mod.func",true[,{...}]) --сохранится, вызов всегда через 10000
start_timer(10000,"mod.func",false[,{...}]) --не сохранится, вызов всегда через 10000
start_timer(10000,"mod.func",200[,{...}]) --не сохранится, вызов всегда через 200, но первый вызов через 10000
]]
function start_timer(time_ms,action,tbl_arg,step)
	if type(tbl_arg) ~= "table" then
		step = tbl_arg
		tbl_arg = {}
	end
	local timer
	if step ~= nil then
		timer = des_timers.timer_cyclic(time_ms,action,tbl_arg,step)
	else
		timer = des_timers.base_timer(time_ms,action,tbl_arg)
	end
	table.insert(active_timers,timer)
	return timer
end
--[[
function start_timer(time_ms,action,step,tbl_arg)
	if step ~= nil and type(step) == "table" then
		tbl_arg = step
		step = nil
	else
		tbl_arg = tbl_arg or {}
	end
	local timer
	if step ~= nil then
		timer = des_timers.timer_cyclic(time_ms,action,tbl_arg,step)
	else
		timer = des_timers.base_timer(time_ms,action,tbl_arg)
	end
	table.insert(active_timers,timer)
	return timer
end
--]]
function start_small_timers()
	des_timers.start_timer(250,"des_dop.coor",false)
	des_timers.start_timer(1000,"rp_ammo.on_update",false)
end

function update_timers(delta)
	if not next(active_timers) then return end
	for key,timer in pairs(active_timers) do
		if timer:update(delta) then
			table.remove(active_timers,key)
		end
	end
end
---------------------------------------------
class "base_timer"
function base_timer:__init(time_ms,action,tbl_arg)
	self.time = time_ms
	self.func_srt = action
	self.func = loadstring(self.func_srt.."(...)")
	if type(tbl_arg) ~= "table" then tbl_arg = {} end
	self.args = tbl_arg
end

function base_timer:update(delta)
	self.time = self.time - delta
	if self.time <= 0 then
		self.func(unpack(self.args))
		return true
	end
	return false
end

function base_timer:pack_timer()
	local tbl = {self.time, self.func_srt}
	if next(self.args) then table.insert(tbl,self.args) end
	return tbl
end

class "timer_cyclic" (des_timers.base_timer)
function timer_cyclic:__init(time_ms,action,tbl_arg,step) super(time_ms,action,tbl_arg)
	if type(step) == "number" then
		self.step = step
		self.save = true
	else
		self.step = time_ms
		self.save = step
	end
end

function timer_cyclic:update(delta)
	if base_timer.update(self,delta) then
		self.time = self.step
	end
	return false
end

function timer_cyclic:pack_timer()
	if not self.save then return end
	local tbl = base_timer.pack_timer(self)
	table.insert(tbl,self.step)
	return tbl
end
---------------------------------------------
local t_id = 1
local t_end_id = 1
local limit = 8000

function save_timers(packet,obj_id)
	if obj_id == db.actor:id() then t_id = 1 t_end_id = #active_timers return end
	if not next(active_timers) or t_id > t_end_id then return packet:w_bool(false) end
	local tbl_timers = {}
	local tail_packet = limit - packet:w_tell()
	while t_id <= t_end_id do
		local info_timer = active_timers[t_id]:pack_timer()
		if info_timer then
			tail_packet = tail_packet - des_dop.size_var(info_timer)
			if tail_packet > 0 then table.insert(tbl_timers,info_timer) else break end
		end
		t_id = t_id + 1
	end
	if next(tbl_timers) then
		packet:w_bool(true)
		des_dop.write_packet(packet,tbl_timers)
	else
		packet:w_bool(false)
	end
end

function load_timers(reader)
	if not reader:r_bool() then return end
	local tbl_timers = des_dop.read_packet(reader)
	local a = #tbl_timers
	while a > 0 do
		des_timers.start_timer(unpack(tbl_timers[a]))
		a = a - 1
	end
end