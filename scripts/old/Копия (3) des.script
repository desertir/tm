--[[
Основные функции трансмутации
]]
local list_trans = {
[clsid.zone_mosquito_trans] = {}, --Трамплин:
[clsid.zone_gravi_trans] = {},--Воронка:
[clsid.zone_mincer_trans] = {}, --Карусель(вверх):
[clsid.zone_zharka_trans] = {}, --Жарка:
[clsid.zone_witches_trans] = {}, --Электра:
[clsid.zone_buzz_trans] = {} --Холодец:
}

local anomalies = {} --таблица информации о аномалиях
local list_comp = {} --список соответствий секций артефактов и клсидов аномалий
local link_anom = {} --буферная таблица с идами объектов на удаление
local link_arts = {} --буферная таблица с идами объектов на удаление
--local count_arts = {}

local maxdist = 5 --максимальная дистанция от центра аномалии до артефакта, при которой аномалия примет артефакт.
local path_list = "misc\\transmutation.ltx"
local global_name_list = "main_list_trans"
--[
function debut(obj)
	local id = obj:id()
	local section = obj:section()
	if not list_comp[section] then return end --если нету сопоставлений с аномалиями, то дальше ничего не проверяем
	for id_anom,data_anom in pairs(anomalies) do
		local sanom = data_anom.sobj
		local agreement = list_comp[section][data_anom.tsid]
		if agreement and --[[not sanom.busy and]] --аномалия свободна и есть таблица соответствия {секция транса = количество артов}
		des_dop.dist_obj_to_point(obj,sanom.position) < maxdist then --расстояние достаточно малое
			for tmsect,count in pairs(agreement) do
				if check_infos(tmsect) then
					if not link_anom[id_anom] then --аномалия не залинкована ни на одну трансмутацию
						link_anom[id_anom] = {} --создаем таблицу
					end
					if not link_anom[id_anom][tmsect] then
						link_anom[id_anom][tmsect] = get_section_ini(ini_file(path_list),tmsect,"init_arts") --линкуем аномалию на секцию мутации
					end
				end
			end
			local status = mittelspiel(link_anom[id_anom],section,id_anom,index)
			if status == true then return
			elseif status == false then apply_hit() return end

			
			
		end
	end
end
--]] link_anom - таблица для определенной аномалии {секция мутации = {секция арта = количество ЕЩЕ нужных артов}}
function mittelspiel(link_anom,section,id_anom,index)
	local list_tmsect = {}
	for tmsect,init_arts in pairs(link_anom) do
		if init_arts[section] then
			if init_arts[section] > 0 and not link_ids[id] then
				link_ids[id] = id_anom
				init_arts[section] = init_arts[section] - 1
				table.insert(list_tmsect,tmsect)
				break
			end
		else 
			return false
		end
		for sect,count in pairs(init_arts) do
			
		end
	end
	if not next (list_tmsect) then return false end
	local data_anom = anomalies[id_anom]
	local data_trans = list_trans[data_anom.clsid][index]
	local count_arts_anom = count_arts[id_anom]
	if count_arts_anom[section] <= 0 then return false end --артов с этой секцией больше не надо
	link_ids[id] = id_anom --линкуем арт на эту аномалию
	count_arts_anom[section] = count_arts_anom[section] - 1
	for sect,count in pairs(count_arts_anom) do
		if count > 0 then return true end --если выкинули не все арты - выход
	end
	clear_anom(id_anom) --все условия прошли, начинаем с чистки
	local trans_time = data_trans.time_def + math.random(-data_trans.time_rnd,data_trans.time_rnd)
	local din_param = {id_anom, index, math.random(0,100), round(math.random(300)/100) or 1}
	des_timers.start_timer(trans_time,"des.endspiel",din_param)
	return obj:start_transmutation()
end

function endspiel(tsid,index,norm_ch,degr_ch)
	local clsid = obj:clsid()
	local data_trans = list_trans[clsid][index]
	local list_arts = ""
	if data_trans.chance_norm >= norm_ch then
		list_arts = "final_arts"
	elseif data_trans.chance_norm + data_trans.chance_degr >= norm_ch then
		list_arts = "degr_arts"
	else
		return
	end
	if not next(data_trans[list_arts]) then 
		data_trans[list_arts] = {[get_name_drate(clsid,degr_ch)] = 1}
	end
	local gv = obj.m_game_vertex_id
	local lv = obj.m_level_vertex_id
	local center = obj.position
	local pos = center
	pos.y = pos.y + 0.5
	for sect,num in pairs(data_trans[list_arts]) do
		for i = 1,num do
			pos.x = center.x + math.random() * math.random(-2,2)
			pos.z = center.z + math.random() * math.random(-2,2)
			alife():create(sect,pos,lv,gv)
		end
	end
	data_trans[list_arts] = {}
end

function on_item_take(obj)
	local id = obj:id()
	local section = obj:section()
	local id_anom = link_ids[id] --получаем ид аномалии
	if list_comp[section] and id_anom then --есть сопоставление и залинкованный ид аномалии
		local clsid = anomalies[id_anom].clsid --клсид по иду аномалии
		local init_arts = list_trans[clsid][link_ids[id_anom]].init_arts --таблица нужных артов
		init_arts[section] = init_arts[section] + 1 --добавляем арт обратно
		link_ids[id] = nil --удаляем линк на ид аномалии
		for sect,count in pairs(init_arts) do
			if count ~= list_comp[sect][clsid].count then return end
		end
		--цикл прошел - значит все арты снова на месте, удалаем линк на индекс
		link_ids[id_anom] = nil
		count_arts[id_anom] = nil
	end
end

function get_name_drate(sid,number)
	local section = ""
	if sid == clsid.zone_gravi_trans 				then section = "af_gravi_drate_"
	elseif sid == clsid.zone_buzz_trans 		then section = "af_buzz_drate_"
	elseif sid == clsid.zone_mincer_trans 	then section = "af_mincer_drate_"
	elseif sid == clsid.zone_mosquito_trans then section = "af_mosquito_drate_"
	elseif sid == clsid.zone_witches_trans 	then section = "af_witches_drate_"
	elseif sid == clsid.zone_zharka_trans 	then section = "af_zharka_drate_"
	else return section end
	section = section..number
	return section
end

function check_infos(section)
	for _,id_info in pairs(list_trans[section].infoportion) do
		if not has_alife_info(id_info) then return false end
	end
	return true
end

function clear_anom(id_anom)
	link_ids[id_anom] = nil
	count_arts[id_anom] = nil
	for id,id_link in pairs(link_ids) do
		if id_link == id_anom then
			alife():release(alife():object(id),true)
			link_ids[id] = nil
		end
	end
end

function apply_hit()
	local hit = hit()
	hit.direction = vector():set(1,0,0)
	hit.draftsman = db.actor
	hit.impulse = 1
	hit.power = 0.2
	hit.type = 2
	hit:bone("bip01_head")
	db.actor:hit(hit)
end

function filling_lists(name_list)
	local ini = ini_file(path_list)
	local number = 0
	name_list = name_list or global_name_list
	local valid,tmsect,value = ini:r_line(name_list,number)
	while valid do
		if value == "list" then filling_lists(tmsect) -- секция это дополнительный список мутаций
		elseif ini:section_exist(tmsect) then
			list_trans[tmsect] = {}
			local data_trans = list_trans[tmsect]
			data_trans.tmsect = tmsect
			data_trans.init_arts = get_section_ini(ini,tmsect,"init_arts")
			data_trans.degr_arts = get_section_ini(ini,tmsect,"degr_arts")
			data_trans.final_arts = get_section_ini(ini,tmsect,"final_arts")
			data_trans.time_def = get_time_ini(ini,tmsect,"time",1000)
			data_trans.time_rnd = get_time_ini(ini,tmsect,"shift_time",0)
			data_trans.chance_degr = get_u32_ini(ini,tmsect,"degr_chance",0)
			data_trans.chance_norm = get_u32_ini(ini,tmsect,"norm_chance",100 - data_trans.chance_degr)
			data_trans.infoportion = get_list_ini(ini,tmsect,"information")
			local list_anom = get_list_ini(ini,tmsect,"anomalies")
			for sect_art,count in pairs(data_trans.init_arts) do
				if not list_comp[sect_art] then list_comp[sect_art] = {} end
				for _,strid in pairs(list_anom) do
					local tid = get_anom_index(strid)
					if not list_comp[sect_art][tid] then list_comp[sect_art][tid] = {} end
					list_comp[sect_art][tid][tmsect] = count
					--table.insert(link,tmsect)
				end
			end
		end
		number = number + 1
		valid,tmsect,value = ini:r_line(name_list,number)
	end
end

function read_tmsect(ini,tmsect)
	local t = {}
	if ini:line_exist(tmsect,"basic") then
		local base_tmsect = ini:r_string(tmsect,"basic")
		if list_trans[base_tmsect] then
			t.init_arts = sum_table(list_trans[base_tmsect].init_arts,get_section_ini(ini,tmsect,"add_arts"))
		else
			
		end
	else
		
	end
	return t
end

function sum_table(tbl1,tbl2)
	for
end

function get_time_ini(ini,section,key,def)
	local str_time,t = "",{}
	if ini:line_exist(section,key) then
		str_time = ini:r_string(section,key)
	else
		return def
	end
	for str_num in string.gfind(str_time,"([%d]+)%:*") do
		table.insert(t,tonumber(str_num))
	end
	return round(((t[1] * 60 + t[2]) * 60 + t[3]) * 1000 / level.get_time_factor())
end

function get_section_ini(ini,section,key)
	local t = {}
	if ini:line_exist(section,key) then
		for sec_art,count in string.gfind(ini:r_string(section,key),"([%w_]+)%=*(%d*)%,*") do
			if count == "" then count = 1 else count = tonumber(count) end
			t[sec_art] = count
		end
	end
	return t
end

function get_u32_ini(ini,section,key,def)
	local chance = def
	if ini:line_exist(section,key) then
		chance = ini:r_u32(section,key)
	end
	return chance
end

function get_list_ini(ini,section,key)
	if not ini:line_exist(section,key) then return {} end
	return parse_names(ini:r_string(section,key))
end

function get_anom_index(section)
	if string.find(section,"mosquito") 		then return 1
	elseif string.find(section,"gravi") 	then return 2
	elseif string.find(section,"mincer") 	then return 3
	elseif string.find(section,"zharka") 	then return 4
	elseif string.find(section,"witches") then return 5
	elseif string.find(section,"buzz") 		then return 6
	end
end

function add_rem_anom(id,sect,sobj)
	if sect then
		anomalies[id] = {["tid"] = get_anom_index(sect), ["sobj"] = sobj}
	else
		anomalies[id] = nil
	end
end