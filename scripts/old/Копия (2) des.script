--[[
Основные функции трансмутации
]]
local list_trans = {
[clsid.zone_mosquito_trans] = {}, --Трамплин:
[clsid.zone_gravi_trans] = {},--Воронка:
[clsid.zone_mincer_trans] = {}, --Карусель(вверх):
[clsid.zone_zharka_trans] = {}, --Жарка:
[clsid.zone_witches_trans] = {}, --Электра:
[clsid.zone_buzz_trans] = {} --Холодец:
}
save_state = {}
local anomalies = {} --таблица информации о аномалиях
local list_comp = {} --список соответствий секций артефактов и клсидов аномалий
local link_ids = {} --буферная таблица с идами объектов на удаление
local count_arts = {}
local maxdist = 5 --максимальная дистанция от центра аномалии до артефакта, при которой аномалия примет артефакт.
local path_list = "misc\\transmutation.ltx"
local global_name_list = "main_list_trans"

function debut(obj)
	local id = obj:id()
	local section = obj:section()
	if not list_comp[section] then return end --если нету сопоставлений с аномалиями, то дальше ничего не проверяем
	for id_anom,data_anom in pairs(anomalies) do pcon(id_anom)
		local agreement = list_comp[section][data_anom.clsid] --таблица соответствия (индекс транса и количество)
		local index = agreement and agreement.index
		if index and check_infos(data_anom.clsid,index) --есть соответствие, вся инфа есть
		and des_dop.dist_obj_to_point(obj,data_anom.position) < maxdist then --расстояние достаточно малое
			if not link_ids[id_anom] then --аномалия не залинкована
				count_arts[id_anom] = get_section_ini(ini_file(path_list),list_trans[data_anom.clsid][index].section,"init_arts")
				link_ids[id_anom] = index --линкуем аномалию на индекс транса
			end
			if link_ids[id_anom] == index then --залинкованный и сопоставляемый индексы равны, все нормально
				if mittelspiel(id,section,id_anom,index) then return end
			elseif link_ids[id_anom] ~= index then --попытка запуска другой трансмутации
				--HIIIT арты прореагируют в аномалии, актору хит
				apply_hit()
				link_ids[id] = id_anom
				clear_anom(id_anom)
			end
		end
	end
end

function mittelspiel(id,section,id_anom,index)
	local data_anom = anomalies[id_anom]
	local data_trans = list_trans[data_anom.clsid][index]
	local count_arts_anom = count_arts[id_anom]
	if count_arts_anom[section] <= 0 then return false end --артов с этой секцией больше не надо
	link_ids[id] = id_anom --линкуем арт на эту аномалию
	count_arts_anom[section] = count_arts_anom[section] - 1
	for sect,count in pairs(count_arts_anom) do
		if count > 0 then return true end --если выкинули не все арты - выход
	end
	clear_anom(id_anom) --все условия прошли, начинаем с чистки
	local trans_time = data_trans.time_def + math.random(-data_trans.time_rnd,data_trans.time_rnd)
	local din_param = {id_anom, index, math.random(0,100), round(math.random(300)/100) or 1}
	des_timers.start_timer(trans_time,"des.endspiel",din_param)
	return true
end

function endspiel(tsid,index,norm_ch,degr_ch)
	local clsid = obj:clsid()
	local data_trans = list_trans[clsid][index]
	local list_arts = ""
	if data_trans.chance_norm >= norm_ch then
		list_arts = "final_arts"
	elseif data_trans.chance_norm + data_trans.chance_degr >= norm_ch then
		list_arts = "degr_arts"
	else
		return
	end
	if not next(data_trans[list_arts]) then 
		data_trans[list_arts] = {[get_name_drate(clsid,degr_ch)] = 1}
	end
	local gv = obj.m_game_vertex_id
	local lv = obj.m_level_vertex_id
	local center = obj.position
	local pos = center
	pos.y = pos.y + 0.5
	for sect,num in pairs(data_trans[list_arts]) do
		for i = 1,num do
			pos.x = center.x + math.random() * math.random(-2,2)
			pos.z = center.z + math.random() * math.random(-2,2)
			alife():create(sect,pos,lv,gv)
		end
	end
	data_trans[list_arts] = {}
end

function on_item_take(obj)
	local id = obj:id()
	local section = obj:section()
	local id_anom = link_ids[id] --получаем ид аномалии
	if list_comp[section] and id_anom then --есть сопоставление и залинкованный ид аномалии
		local clsid = anomalies[id_anom].clsid --клсид по иду аномалии
		local init_arts = list_trans[clsid][link_ids[id_anom]].init_arts --таблица нужных артов
		init_arts[section] = init_arts[section] + 1 --добавляем арт обратно
		link_ids[id] = nil --удаляем линк на ид аномалии
		for sect,count in pairs(init_arts) do
			if count ~= list_comp[sect][clsid].count then return end
		end
		--цикл прошел - значит все арты снова на месте, удалаем линк на индекс
		link_ids[id_anom] = nil
		count_arts[id_anom] = nil
	end
end

function get_name_drate(sid,number)
	local section = ""
	if sid == clsid.zone_gravi_trans 				then section = "af_gravi_drate_"
	elseif sid == clsid.zone_buzz_trans 		then section = "af_buzz_drate_"
	elseif sid == clsid.zone_mincer_trans 	then section = "af_mincer_drate_"
	elseif sid == clsid.zone_mosquito_trans then section = "af_mosquito_drate_"
	elseif sid == clsid.zone_witches_trans 	then section = "af_witches_drate_"
	elseif sid == clsid.zone_zharka_trans 	then section = "af_zharka_drate_"
	else return section end
	section = section..number
	return section
end

function check_infos(clsid,index)
	for _,id_info in pairs(list_trans[clsid][index].infoportion) do --если таблица пуста, все норм
		if not has_alife_info(id_info) then return false end
	end
	return true
end

function clear_anom(id_anom)
	link_ids[id_anom] = nil
	count_arts[id_anom] = nil
	for id,id_link in pairs(link_ids) do
		if id_link == id_anom then
			alife():release(alife():object(id),true)
			link_ids[id] = nil
		end
	end
end

function apply_hit()
	local hit = hit()
	hit.direction = vector():set(1,0,0)
	hit.draftsman = db.actor
	hit.impulse = 1
	hit.power = 0.2
	hit.type = 2
	hit:bone("bip01_head")
	db.actor:hit(hit)
end

function filling_lists(name_list)
	local ini = ini_file(path_list)
	local number = 0
	name_list = name_list or global_name_list
	local valid,section,value = ini:r_line(name_list,number)
	while valid do
		if value == "list" then filling_lists(section) -- секция - дополнительный список мутаций
		elseif ini:section_exist(section) then
			local clsid = ini:r_clsid(section,"anomaly")
			local data_trans = {}
			data_trans.section = section
			data_trans.init_arts = get_section_ini(ini,section,"init_arts")
			data_trans.degr_arts = get_section_ini(ini,section,"degr_arts")
			data_trans.final_arts = get_section_ini(ini,section,"final_arts")
			data_trans.time_def = get_time_ini(ini,section,"time",1000)
			data_trans.time_rnd = get_time_ini(ini,section,"shift_time",0)
			data_trans.chance_degr = get_chance_ini(ini,section,"degr_chance",0)
			data_trans.chance_norm = get_chance_ini(ini,section,"norm_chance",100 - data_trans.chance_degr)
			data_trans.infoportion = get_info_ini(ini,section,"information")
			local index = #list_trans[clsid] + 1
			list_trans[clsid][index] = data_trans
			for sect,count in pairs(data_trans.init_arts) do
				list_comp[sect] = list_comp[sect] or {}
				list_comp[sect][clsid] = {["index"] = index, ["count"] = count}
			end
		end
		number = number + 1
		valid,section,value = ini:r_line(name_list,number)
	end
end

function get_time_ini(ini,section,key,def)
	local str_time,t = "",{}
	if ini:line_exist(section,key) then
		str_time = ini:r_string(section,key)
	else
		return def
	end
	for str_num in string.gfind(str_time,"([%d]+)%:*") do
		table.insert(t,tonumber(str_num))
	end
	return round(((t[1] * 60 + t[2]) * 60 + t[3]) * 1000 / level.get_time_factor())
end

function get_section_ini(ini,section,key)
	if not ini:line_exist(section,key) then return {} end
	local str_sec,t = ini:r_string(section,key),{}
	for sec,num in string.gfind(str_sec,"([%w_]+)%=*(%d*)%,*") do
		if num == "" then num = 1 else num = tonumber(num) end
		t[sec] = num
	end
	return t
end

function get_chance_ini(ini,section,key,def)
	local chance = def
	if ini:line_exist(section,key) then
		chance = ini:r_u32(section,key)
	end
	return chance
end

function get_info_ini(ini,section,key)
	if not ini:line_exist(section,key) then return {} end
	return parse_names(ini:r_string(section,key))
end

function add_rem_anom(id,sid,pos,lv,gv)
	if sid then
		anomalies[id] = {["clsid"] = sid, ["position"] = pos, ["level_vertex"] = lv, ["game_vertex"] = gv}
	else
		anomalies[id] = nil
	end
end