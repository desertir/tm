ev_blow_begin = 20000
ev_blow_in_cover = ev_blow_begin + 1
act_blow_go_cover = ev_blow_begin
act_blow_wait = act_blow_go_cover + 1

local list_cover = {
-- l01_escape = {}
-- l02_garbage
-- l03_agroprom
-- l03u_agr_underground
-- l04_darkvalley
-- l04u_LabX18
-- l05_bar
-- l06_rostok
-- l07_military
-- l08_yantar
-- l08u_brainlab
-- l10_radar
-- l11_pripyat
-- l12_stancia
-- l12_stancia_2
-- l12u_control_monolith
-- l12u_sarcofag
-- dead_forest
}

class "evaluator_in_cover" (property_evaluator)
function evaluator_in_cover:__init(name,storage) super(nil,name)
	self.a = storage
end
function evaluator_in_cover:evaluate()
	local in_zone = npc_in_zone(self.object,self.a.name_zone)
	return in_zone
	--return db.zone_by_name[self.a.name_zone]:inside(self.object:position())
end

class "evaluator_blow_begin" (property_evaluator)
function evaluator_blow_begin:__init(name,storage) super(nil,name)
	self.a = storage
end
function evaluator_blow_begin:evaluate()
	return self.a.enable and has_alife_info("blowout_start")
end

class "action_blow_wait" (action_base)
function action_blow_wait:__init (action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_blow_wait:initialize()
--pcon("action_blow_wait:initialize")
	action_base.initialize(self)
	self.object:set_desired_position()
	self.object:set_desired_direction()
end
function action_blow_wait:execute()
--pcon("action_blow_wait:execute")
	action_base.execute(self)
	state_mgr.set_state(self.object,"sit_ass")
end
function action_blow_wait:finalize()
--pcon("action_blow_wait:finalize")
	action_base.finalize(self)
end

class "action_go_cover" (action_base)
function action_go_cover:__init (action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_go_cover:initialize()
	action_base.initialize(self)
	-- storage активной схемы
	local store = db.storage[self.object:id()]
	local st = store[store.active_scheme]
	-- деактивируем активную схему
	if st and st.actions then
		for action, is_active in pairs(st.actions) do
			--if is_active and action["deactivate"] then action["deactivate"](action,self.object) end
		end
	end
----pcon("action_go_cover:initialize")
	self.object:set_desired_position()
	self.object:set_desired_direction()
	--self.a.pos_vertex = nil
  --self.object:clear_animations()

  -- anim.danger - минимальная скорость, anim.free - нормальная, anim.panic - максимальная
  --self.object:set_mental_state(anim.free)
	state_mgr.set_state(self.object, self.a.def_state_moving)
	self.object:set_path_type(game_object.level_path)
	xr_sound.set_sound(self.object, nil)
	stop_play_sound(self.object)
end
function action_go_cover:execute()
----pcon("action_go_cover:execute")
	action_base.execute(self)
	local tmp_pos_vertex = db.zone_by_name[self.a.name_zone]:level_vertex_id()
	--pcon(tmp_pos_vertex)
	if self.a.pos_vertex ~= tmp_pos_vertex then
		self.a.pos_vertex = tmp_pos_vertex
		
		if not self.object:accessible(self.a.pos_vertex) then
			self.a.pos_vertex = self.object:accessible_nearest(level.vertex_position(self.a.pos_vertex),vector():set(0,0,0))
		end
  --self.object:set_detail_path_type(move.line)
  --self.object:set_body_state(move.standing)
  --self.object:set_movement_type(move.run)
  --self.object:set_path_type(game_object.level_path)
		
		self.a.pp = level.vertex_in_direction(self.a.pos_vertex,vector():set(math.random(-1,1),0,math.random(-1,1)),math.random(0,0.5))
		self.object:set_dest_level_vertex_id(self.a.pos_vertex)
		self.object:set_desired_direction(vector():sub(level.vertex_position(self.a.pp),level.vertex_position(self.a.pos_vertex)))
	end
end
function action_go_cover:finalize()
--pcon("action_go_cover:finalize")
	action_base.finalize(self)
end

function set_scheme(npc,ini,own_section)
	local section,npc_id,scheme,st = read_string(ini,own_section,"on_blowout"),npc:id(),"blowout"
	
	if not db.storage[npc_id][scheme] then
		db.storage[npc_id][scheme] = {}
		st = db.storage[npc_id][scheme]
		st.npc = npc
		st.name_zone = read_string(ini,section,"cover") or get_near_cover(npc)
		st.def_state_moving = read_string(ini,section,"state","walk")
		add_to_binder(st)
	else
		st = db.storage[npc_id][scheme]
	end

	st.enable = st.name_zone ~= "underground"
end

function disable_scheme(npc)
  local st = db.storage[npc:id()]["blowout"]
	if st then st.enable = false end
end

function add_to_binder(st)
	local manager,action = st.npc:motivation_action_manager()
	manager:add_evaluator(ev_blow_begin,this.evaluator_blow_begin("blow_begin",st)) --выброс начался
	manager:add_evaluator(ev_blow_in_cover,this.evaluator_in_cover("blow_in_cover",st)) --в убежище
--идем к убежищу
	action = this.action_go_cover("blow_go_cover",st)
	action:add_precondition(world_property(ev_blow_in_cover,false))
	action:add_effect(world_property(ev_blow_in_cover,true))
	manager:add_action(act_blow_go_cover,action)
--ждем конца выброса
	action = this.action_blow_wait("blow_wait",st)
	action:add_precondition(world_property(ev_blow_in_cover,true))
	action:add_effect(world_property(ev_blow_begin,false))
	manager:add_action(act_blow_wait,action)

	action = manager:action(xr_actions_id.alife)
	action:add_precondition(world_property(ev_blow_begin,false))
end

function add_pre(action)
	action:add_precondition(world_property(stalker_ids.property_alive,true))
	action:add_precondition(world_property(stalker_ids.property_danger,false))
	action:add_precondition(world_property(stalker_ids.property_enemy,false))
	action:add_precondition(world_property(stalker_ids.property_anomaly,false))
end

function addCommonPrecondition(action)
	action:add_precondition (world_property(ev_blow_begin,false))
end

function get_near_cover(npc)
	local ln = level.name()
	if list_cover[ln] == nil then return "underground" end
	local pos = npc:position()
	local dist = 1000000000
	local nzone = ""
	for _,name_zone in pairs(list_cover[ln]) do
		local pos_zone = db.zone_by_name[name_zone]:position()
		local new_dist = pos:distance_to_sqr(pos_zone)
		if new_dist < dist then
			dist = new_dist
			nzone = name_zone
		end
	end
	return nzone
end

function npc_in_zone(npc,name_zone)
	local zone = db.zone_by_name[name_zone]
	if npc == nil or zone == nil then return false
	else return zone:inside(npc:position()) end
end

function read_bool(char_ini,section,field,default_val)
	if section and char_ini:section_exist(section) and char_ini:line_exist(section,field) then
		return char_ini:r_bool(section,field)
	end
	return default_val == true
end

function read_string(char_ini,section,field,default_val,gulag_name)
	if section and char_ini:section_exist(section) and char_ini:line_exist(section,field) then
		if gulag_name and gulag_name ~= "" then
			return gulag_name.."_"..char_ini:r_string(section,field)
		else
			return char_ini:r_string(section,field)
		end
	end
	return default_val
end

function read_number(char_ini, section, field, object, mandatory, default_val)
	if section and char_ini:section_exist(section) and char_ini:line_exist(section,field) then
		return char_ini:r_float(section,field)
	end
	return default_val
end

function get_scheme_by_sect(section)
	local scheme = string.gsub(section, "%d", "")
	local at, to = string.find(scheme, "@", 1, true)
	if at and to then
		scheme = string.sub(scheme, 1, at - 1)
	end
	return scheme
end








